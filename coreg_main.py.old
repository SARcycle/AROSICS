# Angleichung der Ausmasse zwischen GRI und Szene zur Vermeidung eines Speicheroverheads
def equalize_extents(im_reference, im_target):
    from osgeo import gdal
    # open target file and get extent
    target = gdal.Open(im_target, gdal.GA_ReadOnly)
    geoTransform = target.GetGeoTransform()
    minx_target = geoTransform[0]
    maxy_target = geoTransform[3]
    maxx_target = minx_target + geoTransform[1] * target.RasterXSize
    miny_target = maxy_target + geoTransform[5] * target.RasterYSize
    x_size_target, y_size_target = get_raster_dimensions(im_target)

    outputFile = im_reference.replace('.tif', '_masked.tif')

    if os.path.exists(outputFile):  # If there is an output file present with the correct filename
        # open reference file and get extent
        reference = gdal.Open(im_reference, gdal.GA_ReadOnly)
        geoTransform = reference.GetGeoTransform()
        minx_ref = geoTransform[0]
        maxy_ref = geoTransform[3]
        maxx_ref = minx_ref + geoTransform[1] * reference.RasterXSize
        miny_ref = maxy_ref + geoTransform[5] * reference.RasterYSize
        x_size_ref, y_size_ref = get_raster_dimensions(im_reference)

        if minx_target == minx_ref and maxx_target == maxx_ref and miny_target == miny_ref and maxy_target == maxy_ref and x_size_target == x_size_ref and y_size_target == y_size_ref:  # If all extents are equal --> Nothing to do
            return outputFile

    print(f'Cropping Reference Image to Target Image Size')

    # call gdal Warp
    kwargs = {"format": "GTiff", "outputBounds": [minx_target, miny_target, maxx_target, maxy_target]}
    ds = gdal.Warp(outputFile, im_reference, **kwargs)
    return outputFile


def get_raster_dimensions(filepath):
    from osgeo import gdal
    ds = gdal.Open(filepath)
    return ds.RasterXSize, ds.RasterYSize


import time, glob, os
from arosics import COREG_LOCAL
from osgeo import gdal

location = 'CH'  # Gesetztes Suffix der zugeschnittenen Szenen gemäss M:\Appl\DATA\PROD\topo\tbk\tbkn\npoc\Umweltbeobachtung\Trockenheitsmonitoring\KoregistrierungSentinel\AROSICS\Documents_Scripts\SceneCrop_GDAL.sh
base_path = '/mnt/c/Users/Localadmin/Documents/SATROMO/AROSICS_Coregistration/Test/'  # Pfad für In-/Output (Anforderung: Input-Szenen liegen in Unterordner "input"
# grid_res = 30;  # Schrittweite in Pixel pro Tie-Point-Berechnung
max_points = 5000  # Maximale Punktzahl
min_rel = 60
im_reference = '/mnt/c/Users/Localadmin/Documents/SATROMO/AROSICS_Coregistration/Test/CH/input/S2_GRI.tif'

# Iteration über alle Files mit den entsprechenden Namensschema
for im_target in glob.glob(base_path + location + '/input/202*B4_10m_mosaic.tif'):
    start_time = time.time()
    print(f'Retrieving Raster Dimensions')
    x_size, y_size = get_raster_dimensions(im_target)

    grid_res = round((((
                                   x_size * y_size) / max_points) ** .5) / 5) * 5  # Berechnung der Schrittweite in x und y (Rundung auf nächsten 5er), basierend auf einer maximalen Punktzahl und der Raster-Dimension ( ** .5 == Wurzel)

    ### Anpassen gemäss Anforderungen ###
    title_str = f'{os.path.basename(im_target)} | {grid_res}x{grid_res}px | {min_rel}Pct_minReliability'
    print('=' * len(title_str))
    print(title_str)
    print('-' * len(title_str))

    im_reference_masked = equalize_extents(im_reference, im_target)
    print(f'Image preprocessing: {time.time() - start_time} seconds')

    kwargs = {
        'grid_res': grid_res,  # Schrittweite in Pixel pro Tie-Point-Berechnung
        # 'window_size'  : (50,50), # Grösse in Pixel des Referenzfensters
        'path_out': 'auto',
        'projectDir': base_path + location + '/output/TiePoint_GridRes_' + str(grid_res) + 'x' + str(
            grid_res) + 'px_' + str(min_rel) + 'Pct_minReliability',
        'q': False,
        'nodata': (0, 0),  # No-Data Value
        # 'min_reliability'   : min_rel
    }

    ### --- Do not touch below this line --- ###

    intermediate_time_1 = time.time()
    CRL = COREG_LOCAL(im_reference_masked, im_target, **kwargs)
    print(CRL)
    print(f'Tie point calculation: {time.time() - intermediate_time_1} seconds')

    intermediate_time_2 = time.time()
    CRL.correct_shifts()
    print(f'Image correction: {time.time() - intermediate_time_2} seconds')
    print(f'Full runtime: {time.time() - start_time} seconds')

    CRL.tiepoint_grid.to_PointShapefile(
        path_out=base_path + location + '/output/TiePoint_GridRes_' + str(grid_res) + 'x' + str(grid_res) + 'px_' + str(
            min_rel) + 'Pct_minReliability/' + os.path.basename(im_target).replace('tif', 'shp'))
    # try:
    test = CRL.tiepoint_grid.to_interpolated_raster(metric='X_SHIFT_PX')
    # except:
    # print('tiepoint_grid.to_interpolated_raster X_SHIFT_PX not successful')
    # try:
    print(CRL.tiepoint_grid.to_interpolated_raster(metric='Y_SHIFT_PX'))
    # except:
    # print('tiepoint_grid.to_interpolated_raster Y_SHIFT_PX not successful')

    # #CRL_after_corr = COREG_LOCAL(im_reference, CRL.path_out, **kwargs)

    # #CRL_after_corr.view_CoRegPoints(figsize=(15,15),backgroundIm='ref')
    # #CRL.CoRegPoints_table
    # #CRL.tiepoint_grid.to_PointShapefile(path_out='/mnt/d/SATROMO/AROSICS_Coregistration/Test/output_shapefile.shp')
    # # AWS Cost Estimation
    # # https://calculator.aws/#/estimate?id=0a2b8d3c19078290f471fbba9938fa6e2235e875
    print('=' * len(title_str))